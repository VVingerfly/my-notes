## 命令空间的using声明

- 头文件不应包含`using`声明。一般来说位于头文件中的代码不应该使用`using`声明，因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个`using`声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序，可能会产生名字冲突。[p75]



## 标准库类型string

- 初始化`string`对象的方式 [p76]

    ```cpp
    string s1;           //默认初始化，s1是一个空串
    string s2(s1);       //s2是s1的副本
    string s2 = s1;      //等价于s2(s1)，s2是s1的副本
    string s3("value");  //s3是字面值"value"的副本，除了字面值最后的那个空字符外
    string s3 = "value"; //等价于s3("value")，s3是字面值"value"的副本
    string s4(n, 'c');   //把s4初始化为由连续n个字符c组成的串
    ```

- `string`的操作 p[77]

    ```cpp
    os<<s  //将s写到输出流os当中，返回os
    is>>s  //从is中读取字符串赋给s，字符串以空白分隔，返回is
    getline(is，s)  //从is中读取一行赋给s，返回is
    s.empty()  //s为空返回true，否则返回false
    s.size()   //返回s中字符的个数
    s[n]   //返回s中第n个字符的引用，位置n从0计起
    s1+s2  //返回s1和s2连接后的结果
    s1=s2  //用s2的副本代替s1中原来的字符
    s1==s2 //如果s1和s2中所含的字符完全一样，则它们相等；
    s1!=s2 //string对象的相等性判断对字母的大小写敏感
    <, <=, >, >=  //利用字符在字典中顺序进行比较，且对字母的大小写敏感
    ```

- `string::size_type`类型是`size()`函数返回的值，是一个无符号整型。[p79]

- 因为某些历史原因，也为了与C兼容，所以C++语言中的字符串字面值并不是标准库类型`string`的对象。切记，字符串字面值与`string`是不同的类型。两个字符串字面值不能直接相加。[p81]

- `cctype`头文件中定义了一组标准库函数来处理某个特定的字符 p[82]

    ```cpp
    isalnum(c)  //当c是字母或数字时为真
    isalpha(c)  //当c是字母时为真
    iscntrl(c)  //当c是控制字符时为真
    isdigit(c)  //当c是数字时为真
    isgraph(c)  //当c不是空格但可打印时为真
    islower(c)  //当c是小写字母时为真
    isprint(c)  //当c是可打印字符时为真(即c是空格或c具有可视形式)
    ispunct(c)  //当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种
    isspace(c)  //当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符符、进纸符中的一种)
    issupper(c)  //当c是大写字母时为真
    isxdigit(c)  //当c是十六进制数字时为真
    tolower(c)   //如果c是大写字母,输出对应的小写字母;否则原样输出c
    toupper(c)   //如果c是小写字母,输出对应的大写字母;否则原样输出c
    ```


- C++标准库中除了定义C语言特有的功能外，也兼容了C语言的标准库。C语言的头文件形如`name.h`，C++则将这些文件命名为`cname`。也就是去掉了`.h`后缀，文件名`name`之前添加了字母`c`，这里的`c`表示这是一个属于C语言标准库的头文件。

    因此, `cctype`头文件和`ctype.h`头文件的内容是一样的，只不过从命名规来讲更符合C++语言的要求。特别的，在名为`cname`的头文件中定义的名字从属于命名空间`std`，而定义在名为`.h`的头文件中的则不然。

    一般来说，C++程序应该使用名为`cname`的头文件而不使用`name.h`的形式，标准库中的名字总能在命名空间`std`中找到。如果使用`.h`形式的头文件，程序员就不得不时刻牢记哪些是从C语言那儿继承过来的，哪些又是C++语言所独有的。[p82]



## 标准库类型vector

- 初始化`vector`对象的方式 [p87]

    ```cpp
    vector<T> v1  //v1是一个空vector，它潜在的元素是T类型，执行默认初始化
    vector<T> v2(v1)  ///v2中包含有v1中所有元素的副本
    vector<T> v2 = v1 //等价于v2(v1)，v2中包含有v1中所有元素的副本
    vector<T> v3(n,val) //v3包含了n个重复的元素，每个元素的值都是val
    vector<T> v4(n) //v4包含了n个重复地执行了值初始化的对象
    vector<T> v5{a,b,c,...}  //v5包含了初始值个数的元素，每个元素被赋予相应的初始值
    vector<T> v5={a,b,c,...}  //等价于v5{a,b,c,...}
    ```


- 通常情况下，可以只提供`vector`对象容纳的元素数量而略去初始化。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由`vector`对象中元素的类型决定。如果是内置类型比如`int`，则元素初始值自动设为0；如果是某种类类型比如`string`，则元素由类默认初始化，但如果元素类型不支持默认初始化，则必须提供初始的元素值。[p88]

- 如果用的是圆括号，可以说提供的值是用来构造(construct)该`vector`对象的；如果用的是花括号，可以表述成想列表初始化(list initialize)该`vector`对象的。但是 **如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，编译器会尝试用这些值来构造vector对象** 。[p89]

    ```cpp
    vector<int> v1(10);    //v1有10个元素，每个的值都是0
    vector<int> v2{10};    //v2有1个元素，该元素的值为10
    vector<int> v3(10,1);  //v3有10个元素，每个的值都是1
    vector<int> v4{10,1};  //v4有2个元素，值分别为10个1

    vector<string> v5{"hi"};    //列表初始化：v5有一个元素
    vector<string> v6("hi");    //错误：不能使用字符串字面值构建vector对象
    vector<string> v7{10};      //v7有10个默认初始化的元素
    vector<string> v8{10,"hi"}; //v8有10个值为"hi"的元素
    ```

- 范围`for`语句体内不应改变其所遍历序列的大小。[p91]

- `vector`支持的操作 [p91]

    ```cpp
    v.empty()      //如果v不含有任何元素，返回真；否则返回假
    v.size()       //返回v中元素的个数
    v.push_back(t) //向v的尾端添加一个值为t的元素
    v[n]    //返回v中第n个位置上元素的引用
    v1 = v2 //用v2中元素的拷贝替换v1中的元素
    v1 = {a,b,c,...} //用列表中元素的拷贝替换v1中的元素
    v1 == v2   //v1和v2相等当且仅当它们的元素数量相同且对应
    v1 != v2   //位置的元素值都相同
    <,<=,>,>=  //顾名思义，以字典顺序进行比较
    ```



## 迭代器介绍

- 迭代器(iterator)都拥有名为`begin`和`end`的成员。`begin`成员负责返回指向第一个元素(或第一个字符)的迭代器；`end`成员负责返回指向容器(或`string`对象)"尾元素的下一个位置"，所以又称为尾后迭代器。[p95]

- 标准容器迭代器的运算符p[96]

    ```cpp
    *iter     //返回迭代器iter所指元素的引用
    iter->mem  //解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
    ++iter  //令iter指示容器中的下一个元素
    --iter   //名iter指示容器中的上一个元素
    iter1 == iter2  //判断两个迭代器是否相等(不相等)，如果两个迭代器指示的是同一个元素
    iter1 != iter2  //或者他们是同一个容器的尾后迭代器，则相等；反之，不相等
    ```

- 迭代器类型[p97]

    ```cpp
    vector<int>::iterator it; //it能读写vector<int>的元素
    string::iterator it2;     //it2能读写string的元素

    vector<int>::const_iterator it3;  //it3只能读元素，不能写元素
    string::const_iterator it4;       //it4只能读字符，不能写字符
    ```

- 但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。[p99]

- `vector`和`string`迭代器支持的额外运算符[p99]

    ```cpp
    iter + n  //指示向后移动了n个元素的新元素
    iter - n  //指示向前移动了n个元素的新元素
    iter += n  //将iter加n的结果赋值给iter
    iter -= n  //将iter减n的结果赋值给iter
    iter1 - iter2  //两个迭代器相减的结果是它们之间的距离，也就是说，将iter2向前移动差值个元素后将得到iter1
    >, >=, <, <=   //如果某迭代器的位置在另一个迭代器之前，则说前者小于后者
    ```




## 数组



## 多维数组
