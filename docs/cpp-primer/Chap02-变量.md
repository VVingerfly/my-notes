

- 初始化和赋值是两个完全不同的操作，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而已一个新值来代替。[p39]



- 定义于任何函数体之外的变量被初始化为0。定义于函数体内部的内置类型变量 **不被初始化**，其值未定义。没有显式初始值的局部静态变量(local static object)将执行值初始化，内置类型的局部静态变量初始化为0。[p40]



- 为了支持分离式编译，C++语言将声明和定义区分开来，声明(declaration)使得名字为程序所知，定义(definition)负责创建与名字关联的实体。如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显示地初始化变量：

    ```cpp
    extern int i;      // 声明i而非定义i
    int j;             // 声明并定义j
    extern int k = 0;  // 定义k，任何包含显式初始化的声明即成为定义
    ```

    如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，但绝对不能重复定义。 [p41]



- 用户自定义标识符不能连续出现两个下划线，也不能以下划线紧接大写字母开头。[p42]



- 引用(reference)是引用(refer to)另外一种类型的复合类型(compound type)。**引用并非对象**，它只是为一个已经存在的对象所起的另外一个名字，所以不能定义引用的引用。引用必须初始化，定义引用时，程序把引用和它的初始值绑定在一起，一旦初始化完成，引用将和它的初始值对象一直绑定在一起。p[45]



- 指针(pointer)是指向(point to)另外一种类型的复合类型(compound type)。指针本身就是一个对象，允许对指针赋值和拷贝，其在定义时无需赋初值，也可以先后指向几个不同的对象。指针存放某个对象的地址，要想获取该地址，需要使用 **取地址符(&)**。如果指针指向了一个对象，允许使用 **解引用符(*)** 来访问该对象。给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。p[47]

    **void*** 是一种特殊的指针类型，可 ==用于存放任意对象的地址==，但对于该地址中到底是个什么类型的对象并不了解，因此 ==不能直接操作void\*指针所指向的对象==。一般拿它和别的指针比较、作为函数的输入或输出，或者赋给另外一个void\*指针。概括来说，以void*的视角来看内存空间也就仅仅是内存空间，没办法访问内存空间中所存的对象。p[50]



- **顶层const** 表示指针本身是个常量，**底层const** 表示指针所指的对象是一个常量。更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用；底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是指针既可以是顶层const也可以是底层const。[p67]



- **指向常量的指针** (pointer to const)不能改变其所指对象的值。**常量指针**(const pointer)说明指针是一个常量，指存放在指针中的那个地址不能改变，而不是其指向的那个值。p[56]

    ```cpp
    const double pi = 3.14;
    const double *ptr_cval = &pi;   // ptr_cval是一个指向常量对象的普通指针
    double *const ptr_cloc = &pi;   // ptr_cloc是一个常量指针
    const double *const cptr = &pi; // cptr是一个指向常量对象的常量指针
    constexpr double *ptr_c = &pi;  // ptr_c是一个常量指针
    ```



- 类型别名(type alias)的定义有两种形式[p60]：

    - 使用`typedef`关键字

        ```cpp
        typedef double REAL;  // REAL是double的同义词
        typedef REAL base, *basep; // base是double的同义词，basep是double*的同义词
        ```

    - 使用别名申明(alias declaration)

        ```cpp
        using count = int;  // count是int的同义词
        ```

    注意：遇到了使用类型别名的申明语句时，将类型别名替换为它本来的样子来理解是 ==错误== 的：

    ```cpp
    typedef char* pstring; // pstring是指向char的指针
    const pstring cstr = 0 // cstr是指向char的常量指针，而非指向常量字符的指针
    // const char *cstr = 0;是对上面语句的错误理解，这里的cstr是一个指向const char的普通指针
    const pstring *ps;  // ps是一个指针，它的对象是指向char的常量指针
    ```



- 类型说明符`auto`让编译器通过初始值来推算变量的类型，因而其定义的变量必须有初始值。[p61]

    编译器推断出的`auto`类型有时候和初始值的类型并不完全一样，编译器会适当改变结果类型使其更符合初始化规则。

  - 当引用被用作初始值时，真正参与初始化的其实是引用对象的值

    ```cpp
    int i = 0, &r = i;
    auto a = r;  // a是一个整数(r是i的别名，而i是一个整数)
    ```

  - `auto`一般会忽略顶层`const`，同时底层`const`会保留下来

    ```cpp
    const int ci = i, &cr = ci;
    auto b = ci;  //b是一个整数(ci的顶层const特性被忽略掉了)
    auto c = cr;  //c是一个整数(cr是ci的别名，ci本身是一个顶层const)
    auto d = &i;  //d是一个整型指针(整数的地址就是指向整数的指针)
    auto e = &ci; //e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
    ```

    如果希望推断出的`auto`类型是一个顶层`const`，需要明确指出：

    ```cpp
    const auto f = ci;  // ci的推演类型是int，f是const int
    ```

    还可以将引用的类型设为`const`，此时原来的初始化规则仍然适用：

    ```cpp
    auto &g = ci;  //g是一个整型常量引用，绑定到ci
    auto &h = 42;  //错误：不能为非常量引用绑定字面值
    const auto &j = 42; //正确：可以为常量引用绑定字面值
    ```

- **decltype** 是C++11引入的第二种类型说明符，它的作用是选择并返回操作数的数据类型，在此过程中编译器分析表达式并得到它的数据类型，却不实际计算表达式的值[p62]：

    ```cpp
    decltype (f()) sum = x; // sum的类型就是函数f的返回类型
    ```

  - `decltype`处理顶层`const`和引用的方式与`auto`有些许不同。如果`decltype`使用的表达式是一个变量，则`decltype`则返回该变量的类型(包括顶层`const`和引用在内)：

    ```cpp
    const int ci = 0, &cj = ci;
    decltype(ci) x = 0; //x的类型是const int
    decltype(cj) y = x; //y的类型是const int&，y绑定到变量x
    decltype(cj) z;  // 错误：z是一个引用，必须初始化
    ```

  - `decltype`和`auto`的另一处重要区别是，`decltype`的结果类型与表达式形式密切相关。有一种情况特别注意：对于`decltype`所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。[p63]

    切记`decltype ((variable))`的结果永远是引用(注意是双层括号)，而`decltype (variable)`的结果只有当variable本身就是一个引用时才是引用。
